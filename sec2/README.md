# POSTGRESQL Database Queries

## Section 2. Filtering Data

## WHERE clause
* The syntax of the PostgreSQL WHERE clause is as follows:
```
SELECT select_list FROM table_name WHERE condition ORDER BY sort_expression;
```

* The WHERE clause appears right after the FROM clause of the SELECT statement.  The WHERE clause uses the condition to filter the rows returned from the SELECT clause.

* The condition must evaluate to true, false, or unknown. It can be a boolean expression or a combination of boolean expressions using the AND and OR operators.

* The query returns only rows that satisfy the condition in the WHERE clause. In other words, only rows that cause the condition evaluates to true will be included in the result set.

### 1)  Using WHERE clause with the equal (=) operator example
* The following statement uses the WHERE clause customers whose first names are Jamie:
```
SELECT last_name, first_name FROM customer WHERE first_name = 'Jamie';
```
### 2) Using WHERE clause with the AND operator example
* The following example finds customers whose first name and last name are Jamie and rice by using the AND logical operator to combine two Boolean expressions:
```
SELECT last_name, first_name FROM customer WHERE first_name = 'Jamie' AND last_name = 'Rice';
```

### 3) Using the WHERE clause with the OR operator example
* This example finds the customers whose last name is Rodriguez or first name is Adam by using the OR operator:
```
SELECT first_name, last_name FROM customer WHERE last_name = 'Rodriguez' OR first_name = 'Adam';
```

### 4) Using WHERE clause with the IN operator example
* If you want to match a string with any string in a list, you can use the IN operator.

* For example, the following statement returns customers whose first name is Ann, or Anne, or Annie:
```
SELECT first_name, last_name FROM customer WHERE first_name IN ('Ann','Anne','Annie');
```

### 5) Using the WHERE clause with the LIKE operator example
* To find a string that matches a specified pattern, you use the LIKE operator. The following example returns all customers whose first names start with the string Ann:
```
SELECT first_name, last_name FROM customer WHERE first_name LIKE 'Ann%'
```

### 6) Using the WHERE clause with the BETWEEN operator example
* The following example finds customers whose first names start with the letter A and contains 3 to 5 characters by using the BETWEEN operator.

* The BETWEEN operator returns true if a value is in a range of values.
```
SELECT first_name, LENGTH(first_name) name_length FROM customer WHERE first_name LIKE 'A%' AND LENGTH (first_name) BETWEEN 3 AND 5 ORDER BY name_length;
```

### 7) Using the WHERE clause with the not equal operator (<>) example
* This example finds customers whose first names start with Bra and last names are not Motley:
```
SELECT first_name, last_name FROM customer WHERE first_name LIKE 'Bra%' AND last_name <> 'Motley';
```


## LIMIT clause
* PostgreSQL LIMIT is an optional clause of the SELECT statement that constrains the number of rows returned by the query.

* The following illustrates the syntax of the LIMIT clause:
```
SELECT select_list FROM table_name ORDER BY sort_expression LIMIT row_count;
```

* The statement returns row_count rows generated by the query. If row_count is zero, the query returns an empty set. In case row_count is NULL, the query returns the same result set as it does not have the LIMIT clause.

* In case you want to skip a number of rows before returning the row_count rows, you use OFFSET clause placed after the LIMIT clause as the following statement:
```
SELECT select_list FROM table_name LIMIT row_count OFFSET row_to_skip;
```

* The statement first skips row_to_skip rows before returning row_count rows generated by the query. If row_to_skip is zero, the statement will work like it doesn’t have the OFFSET clause.

* Because a table may store rows in an unspecified order, when you use the LIMIT clause, you should always use the ORDER BY clause to control the row order. If you don’t use the ORDER BY clause, you may get a result set with the unspecified order of rows.

### 1) Using PostgreSQL LIMIT to constrain the number of returned rows example
* This example uses the LIMIT clause to get the first five films sorted by film_id:
```
SELECT film_id, title, release_year FROM film ORDER BY film_id LIMIT 5;
```

### 2) Using PostgreSQL LIMIT with OFFSET example
* To retrieve 4 films starting from the fourth one ordered by film_id, you use both LIMIT and OFFSET clauses as follows:
```
SELECT film_id, title, release_year FROM film ORDER BY film_id LIMIT 4 OFFSET 3;
```

### 3) Using PostgreSQL LIMIT OFFSSET to get top / bottom N rows
* Typically, you often use the LIMIT clause to select rows with the highest or lowest values from a table.

* For example, to get the top 10 most expensive films in terms of rental, you sort films by the rental rate in descending order and use the LIMIT clause to get the first 10 films. The following query illustrates the idea:
```
SELECT film_id, title, rental_rate FROM film ORDER BY rental_rate DESC LIMIT 10;
```


## FETCH clause
* To constrain the number of rows returned by a query, you often use the LIMIT clause. The LIMIT clause is widely used by many relational database management systems such as MySQL, H2, and HSQLDB. However, the LIMIT clause is not a SQL-standard.

* To conform with the SQL standard, PostgreSQL supports the FETCH clause to retrieve a number of rows returned by a query. Note that the FETCH clause was introduced in SQL:2008.

* The following illustrates the syntax of the PostgreSQL FETCH clause:

```
OFFSET start { ROW | ROWS } FETCH { FIRST | NEXT } [ row_count ] { ROW | ROWS } ONLY
```
* In this syntax:

* `ROW` is the synonym for `ROWS`, `FIRST` is the synonym for `NEXT` . SO you can use them interchangeably
* The `start` is an integer that must be zero or positive. By default, it is zero if the `OFFSET` clause is not specified. In case the `start` is greater than the number of rows in the result set, no rows are returned;
* The `row_count` is 1 or greater. By default, the default value of `row_count` is 1 if you do not specify it explicitly.
* Because the order of rows stored in the table is unspecified, you should always use the `FETCH` clause with the `ORDER BY` clause to make the order of rows in the returned result set consistent.

> Note : The OFFSET clause must come before the FETCH clause in SQL:2008. However, OFFSET and FETCH clauses can appear in any order in PostgreSQL.

### FETCH vs. LIMIT
* The `FETCH` clause is functionally equivalent to the `LIMIT` clause. If you plan to make your application compatible with other database systems, you should use the `FETCH` clause because it follows the standard SQL.

* The following query use the FETCH clause to select the first film sorted by titles in ascending order:
```
SELECT film_id, title FROM film ORDER BY title FETCH FIRST ROW ONLY;
```
* It is equivalent to the following query:

```
SELECT film_id, title FROM film ORDER BY title FETCH FIRST 1 ROW ONLY;
```

* The following query use the FETCH clause to select the first five films sorted by titles:

```
SELECT film_id, title FROM film ORDER BY title FETCH FIRST 5 ROW ONLY;
```

* The following statement returns the next five films after the first five films sorted by titles:

```
SELECT film_id, title FROM film ORDER BY title OFFSET 5 ROWS FETCH FIRST 5 ROW ONLY; 
```

## IN operator
* You use `IN` operator in the WHERE clause to check if a value matches any value in a list of values.

* The syntax of the `IN` operator is as follows:
```
value IN (value1,value2,...)
```
* The `IN` operator returns true if the value matches any value in the list i.e., value1 , value2 , …

* The list of values can be a list of literal values such as numbers, strings or a result of a `SELECT` statement like this:
```
value IN (SELECT column_name FROM table_name);
```
* The query inside the parentheses is called a subquery, which is a query nested inside another query. 

* For Example

* If you want to know the rental information of customer id 1 and 2, you can use the `IN` operator in the `WHERE` clause as follows:
```
SELECT customer_id, rental_id, return_date FROM rental WHERE customer_id IN (1, 2) ORDER BY return_date DESC;
```

* The following query uses the equal (`=`) and `OR` operators instead of the `IN` operator. It is equivalent to the query above:
```
SELECT rental_id,customer_id,return_date FROM rental WHERE customer_id = 1 OR customer_id = 2 ORDER BY return_date DESC;
```

## NOT IN operator
* You can combine the `IN` operator with the NOT operator to select rows whose values do not match the values in the list.

* For example, the following statement finds all rentals with the customer id is not 1 or 2.
```
SELECT customer_id,rental_id,return_date FROM rental WHERE customer_id NOT IN (1, 2);
```

* Similar to the `IN` operator, you can use the not equal (`<>`) and `AND` operators to write the `NOT IN` operator:
```
SELECT customer_id,rental_id,return_date FROM rental WHERE customer_id <> 1 AND customer_id <> 2;
```
* This query returns the same output as above query that use the `NOT IN` operator.

### IN with a subquery
* The following query returns a list of customer ids from the rental table with the return date is 2005-05-27:
```
SELECT customer_id FROM rental WHERE CAST (return_date AS DATE) = '2005-05-27'ORDER BY customer_id;
```
* Because this query returns a list of values, you can use it as the input of the IN operator like this:

SELECT customer_id,first_name,last_name FROM customer WHERE customer_id IN (SELECT customer_id FROM rental WHERE CAST (return_date AS DATE) = '2005-05-27') ORDER BY customer_id;


## BETWEEN operator
* You use the `BETWEEN` operator to match a value against a range of values. 
* The following illustrates the syntax of the `BETWEEN` operator:
```
value BETWEEN low AND high;
```
* If the value is greater than or equal to the low value and less than or equal to the high value, the expression returns true, otherwise, it returns false.

* You can rewrite the `BETWEEN` operator by using the greater than or equal (`>=`) or less than or equal (`<=`) operators like this:
```
value >= low and value <= high
```
* If you want to check if a value is out of a range, you combine the `NOT` operator with the `BETWEEN` operator as follows:
```
value NOT BETWEEN low AND high;
```
* The following expression is equivalent to the expression that uses the `NOT` and `BETWEEN` operators:
```
value < low OR value > high
```
* You often use the `BETWEEN` operator in the `WHERE` clause of a `SELECT`, `INSERT`, `UPDATE` or `DELETE` statement.

* For Example: 

* The following query use the `BETWEEN` operator to select payments whose amount is between 8 and 9 (USD):
```
SELECT customer_id,payment_id,amount FROM payment WHERE amount BETWEEN 8 AND 9;
```
* To get payments whose amount is not in the range of 8 and 9, you use the following query:
```
SELECT customer_id,payment_id,amount FROM payment WHERE amount NOT BETWEEN 8 AND 9;
```
* If you want to check a value against of date ranges, you should use the literal date in ISO 8601 format i.e., YYYY-MM-DD. 
* For example, to get the payment whose payment date is between 2007-02-07 and 2007-02-15, you use the following query:
```
SELECT customer_id, payment_id, amount, payment_date FROM payment WHERE payment_date BETWEEN '2007-02-07' AND '2007-02-15';
```

## LIKE operator
* Suppose that you want to find a customer but you do not remember her name exactly. However, you just remember that her name begins with something like Jen.

* How do you find the exact customer from the database? You may find the customer in the  customer table by looking at the first name column to see if there is any value that begins with Jen. It will be time-consuming if the customer table has many rows.

* Fortunately, you can use the `LIKE` operator to match the first name of the customer with a string like this query:
```
SELECT first_name,last_name FROM customer WHERE first_name LIKE 'Jen%';
```
* Notice that the `WHERE` clause contains a special expression: the `first_name`, the `LIKE` operator and a string that contains a percent sign (%). The string '`Jen%`' is called a pattern.

* The query returns rows whose values in the `first_name` column begin with Jen and may be followed by any sequence of characters. This technique is called pattern matching.

* You construct a pattern by combining literal values with wildcard characters and use the `LIKE` or `NOT LIKE` operator to find the matches. PostgreSQL provides you with two wildcards:

- Percent sign (`%`) matches any sequence of zero or more characters.
- Underscore sign (`_`)  matches any single character.

* The syntax of LIKE operator is as follows:
```
value LIKE pattern
```

* The expression returns true if the value matches the pattern.

* To negate the `LIKE` operator, you use the `NOT` operator as follows:
```
value NOT LIKE pattern
```

* The `NOT LIKE` operator returns true when the value does not match the pattern.

* If the pattern does not contain any wildcard character, the `LIKE` operator behaves like the equal (`=`) operator.

* LIKE Example: 
```
SELECT 'foo' LIKE 'foo', -- true 
'foo' LIKE 'f%', -- true 
'foo' LIKE '_o_', -- true 
'bar' LIKE 'b_'; -- false 
```

* The first expression returns true because the foopattern does not contain any wildcard character so the `LIKE` operator acts like the equal (`=`) operator.
* The second expression returns true because it matches any string that begins with the letter `f` and followed by any number of characters.
* The third expression returns true because the pattern (`_o_`) matches any string that begins with any single character, followed by the letter `o` and ended with any single character.
* The fourth expression returns false because the pattern  `b_` matches any string that begins with the letter `b` and followed by any single character.
* It’s possible to use wildcards at the beginning and/or end of the pattern.

* For example, the following query returns customers whose first name contains  er string like Jenifer, Kimberly, etc.
```
SELECT first_name,last_name FROM customer WHERE first_name LIKE '%er%' ORDER BY first_name;
```

* You can combine the percent (`%`) with underscore (`_`) to construct a pattern as the following example:
```
SELECT first_name,last_name FROM customer WHERE first_name LIKE '_her%' ORDER BY first_name;
```
* The pattern `_her%` matches any string that:
* Begin with any single character (`_`)
* And is followed by the literal string `her`.
* And is ended with any number of characters.
* The returned first names are Cheryl, Sherri, Sherry, and Therasa.

* NOT LIKE examples
The following query uses the NOT LIKE operator to find customers whose first names do not begin with Jen:
```
SELECT first_name,last_name FROM customer WHERE first_name NOT LIKE 'Jen%' ORDER BY first_name
```
```
SELECT first_name, last_name FROM customer WHERE first_name ILIKE 'BAR%';
```

## NULL and IS NULL operator
* In the database world, NULL means missing information or not applicable. NULL is not a value, therefore, you cannot compare it with any other values like numbers or strings. The comparison of NULL with a value will always result in NULL, which means an unknown result.

* In addition, NULL is not equal to NULL so the following expression returns NULL:
```
NULL = NULL
```

* Assuming that you have a contacts table that stores the first name, last name, email, and phone number of contacts. At the time of recording the contact, you may not know the contact’s phone number.

* To deal with this, you define the phone column as a nullable column and insert NULL into the phone column when you save the contact information.
```
CREATE TABLE contacts(
    id INT GENERATED BY DEFAULT AS IDENTITY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    email VARCHAR(255) NOT NULL,
    phone VARCHAR(15),
    PRIMARY KEY (id)
);
```
> Note: If you get an error while executing the CREATE TABLE statement, your PostgreSQL version may not support the identity column syntax. In this case, you can use the following statement:
```
CREATE TABLE contacts(
    id SERIAL,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    email VARCHAR(255) NOT NULL,
    phone VARCHAR(15),
    PRIMARY KEY (id)
);
```
* The following statement inserts two contacts, one has a phone number and the other does not:
```
INSERT INTO contacts(first_name, last_name, email, phone)
VALUES ('John','Doe','john.doe@example.com',NULL),
    ('Lily','Bush','lily.bush@example.com','(408-234-2764)');
```
* To find the contact who does not have a phone number you may come up with the following statement:
```
SELECT id,first_name,last_name,email,phone FROM contacts WHERE phone = NULL;
```
* The statement returns no row. This is because the expression `phone = NULL` in the `WHERE` clause always returns false.

* Even though there is a `NULL` in the phone column, the expression `NULL = NULL returns false`. This is because `NULL` is `not equal` to any value `even itself`.

* To check whether a value is NULL or not, you use the IS NULL operator instead:
```
value IS NULL
```

* The expression returns true if the value is NULL or false if it is not.

* So to get the contact who does not have any phone number stored in the phone column, you use the following statement instead:
```
SELECT id,first_name,last_name,email,phone FROM contacts WHERE phone IS NULL;
```
## IS NOT NULL operator
* To check if a value is not NULL, you use the `IS NOT NULL` operator:
```
value IS NOT NULL
```
* The expression returns true if the value is not NULL or false if the value is NULL.

* For example, to find the contact who does have a phone number, you use the following statement:
```
SELECT id,first_name,last_name,email,phone FROM contacts WHERE phone IS NOT NULL;
```